package org.example.dp;

import java.io.*;
import java.util.*;

/*
 * ===== 문제 분석부터 DP 접근까지의 사고 과정 =====
 *
 * 【1단계: 문제 이해 및 특성 파악】
 * 문제: N개의 물건, 각각 무게와 가치가 있음. 무게 제한 K 내에서 최대 가치를 구하기
 *
 * 초기 접근 고민:
 * - 완전탐색? → 2^N가지 경우 → N≤100이면 불가능 (2^100은 너무 큼)
 * - 그리디? → 가치/무게 비율로 정렬 후 선택? → 반례 존재 (부분 선택 불가)
 * - 백트래킹? → 가지치기 해도 여전히 지수적 시간
 *
 * 【2단계: DP 가능성 판단 - 핵심 질문들】
 * ✓ "최적 부분 구조"가 있는가?
 *   → i번째 물건까지 고려한 최적해 = (i-1)번째까지의 최적해 + i번째 선택 결과
 * ✓ "중복되는 부분 문제"가 있는가?
 *   → 같은 (물건 개수, 남은 용량) 상황이 여러 번 발생
 * ✓ "선택의 독립성"이 있는가?
 *   → i번째 물건의 선택이 이후 선택에 영향을 주지 않음 (용량만 줄어들 뿐)
 *
 * 【3단계: DP 상태(State) 정의하기】
 * 사고 과정:
 * - 어떤 정보가 필요한가? → "몇 번째 물건까지 봤는지" + "남은 용량"
 * - 중복 계산을 피하려면? → (물건 인덱스, 용량) 조합별로 결과 저장
 *
 * 상태 정의: dp[i][w] = i번째 물건까지 고려했을 때, 용량 w에서의 최대 가치
 *
 * 【4단계: 점화식 도출 과정】
 * 각 물건에 대한 선택지 분석:
 * 1) i번째 물건을 선택하지 않는 경우:
 *    → dp[i][w] = dp[i-1][w] (이전 상태 그대로)
 *
 * 2) i번째 물건을 선택하는 경우 (w >= weight[i]일 때만 가능):
 *    → dp[i][w] = dp[i-1][w-weight[i]] + value[i]
 *    (용량을 weight[i]만큼 사용하고, 가치 value[i]를 얻음)
 *
 * 최종 점화식:
 * dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])
 *
 * 【5단계: 기저 조건(Base Case) 설정】
 * - dp[0][w] = 0 (물건이 없으면 가치는 0)
 * - dp[i][0] = 0 (용량이 0이면 아무것도 담을 수 없음)
 *
 * ===== 범용적인 DP 문제 해결 사고 과정 =====
 *
 * 【Step 1: DP 판별 체크리스트】
 * □ 최적화 문제인가? (최대/최소/개수 구하기)
 * □ 완전탐색으로는 시간초과가 날 정도로 경우의 수가 많은가?
 * □ 큰 문제를 작은 문제로 나눌 수 있는가?
 * □ 작은 문제의 답이 큰 문제의 답에 영향을 주는가? (최적 부분 구조)
 * □ 같은 부분 문제가 여러 번 계산되는가? (중복 부분 문제)
 *
 * 【Step 2: 상태 설계 전략】
 * 1) "무엇이 변하는가?" 찾기 → 상태 변수 후보
 * 2) "결정해야 할 것은 무엇인가?" → 상태 변수 확정
 * 3) "메모리 제한을 고려한 차원 설계"
 *
 * 예시:
 * - 배낭: (물건 인덱스, 용량)
 * - 피보나치: (n번째)
 * - LCS: (문자열1 인덱스, 문자열2 인덱스)
 * - 계단오르기: (현재 계단, 연속 올라간 횟수)
 *
 * 【Step 3: 점화식 도출 방법론】
 * 1) 현재 상태에서 가능한 선택지 나열
 * 2) 각 선택이 다음 상태에 어떤 영향을 주는지 분석
 * 3) 이전 상태들의 최적해를 이용해 현재 상태의 최적해 표현
 * 4) 선택지들 중 최적값 선택 (max, min 등)
 *
 * 【Step 4: 구현 시 주의사항】
 * 1) 인덱스 범위 확인 (0-based vs 1-based)
 * 2) 기저 조건 명확히 설정
 * 3) 갱신 순서 고려 (이전 값이 필요한 경우)
 * 4) 메모리 최적화 가능성 검토
 *
 * 【Step 5: 디버깅 전략】
 * 1) 작은 예제로 손으로 DP 테이블 채워보기
 * 2) 점화식이 모든 경우를 포함하는지 확인
 * 3) 경계 조건에서 오류가 없는지 체크
 *
 * ===== 0-1 배낭 문제 (0-1 Knapsack Problem) =====
 *
 * 【기본 개념】
 * - 각 물건을 담거나 담지 않거나 하는 2가지 선택만 가능 (0-1의 의미)
 * - 배낭의 무게 제한 내에서 가치의 합을 최대화하는 문제
 * - 동적 계획법(Dynamic Programming)의 대표적인 예제
 *
 * 【시간복잡도】
 * - 시간복잡도: O(N × K) (N: 물건 개수, K: 배낭 용량)
 * - 공간복잡도: O(N × K) 또는 O(K) (1차원 최적화 시)
 *
 * 【사전 지식】
 * 1. 동적 계획법(DP) 기본 개념
 * 2. 메모이제이션과 점화식 이해
 * 3. 2차원 배열 접근법과 최적화된 1차원 배열 접근법
 *
 * ===== 코딩테스트에서의 활용 =====
 *
 * 【주요 문제 유형】
 * 1. 배낭 문제 직접 변형 (물건 선택, 예산 배분)
 * 2. 부분집합 합 문제 (Subset Sum)
 * 3. 동전 교환 문제 변형 (각 동전을 1개씩만 사용)
 * 4. 자원 할당 최적화 문제
 * 5. 선택/비선택이 명확한 최적화 문제
 *
 * 【출제 키워드】
 * - "N개 중에서 선택", "용량 제한", "최대 가치/이익"
 * - "예산 내에서", "무게 제한", "각각 하나씩만"
 *
 * ===== 유사 알고리즘과 주의점 =====
 *
 * 【착각하기 쉬운 알고리즘들】
 * 1. 무한 배낭 문제 (Unbounded Knapsack)
 *    - 차이점: 각 물건을 여러 번 선택 가능
 *    - 실수: 0-1 배낭에서 물건을 중복 선택하려 할 때
 *
 * 2. 분할 가능 배낭 문제 (Fractional Knapsack)
 *    - 차이점: 물건을 부분적으로 담을 수 있음 (그리디로 해결)
 *    - 실수: DP 대신 그리디를 쓰거나 그 반대
 *
 * 3. 다중 배낭 문제 (Multiple Knapsack)
 *    - 차이점: 각 물건마다 개수 제한이 있음
 *    - 실수: 개수 제한을 고려하지 않음
 *
 * 4. 그리디 알고리즘
 *    - 실수: 가치/무게 비율로 정렬 후 그리디 선택
 *    - 주의: 0-1 배낭은 그리디로 최적해를 보장할 수 없음!
 *
 * 【문제 유형별 잘못된 접근】
 * - 동전 문제: 0-1 배낭 ↔ 무한 배낭 혼동
 * - 조합/순열 문제: 백트래킹 ↔ DP 혼동
 * - 최단경로: 다익스트라 ↔ DP 혼동
 */

public class DP배낭 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken()); // 물품의 수
        int K = Integer.parseInt(st.nextToken()); // 배낭의 무게 제한

        // 물품 정보 저장 배열
        int[] weight = new int[N + 1]; // 각 물품의 무게 (1-indexed)
        int[] value = new int[N + 1];  // 각 물품의 가치 (1-indexed)

        // 물품 정보 입력 받기
        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            weight[i] = Integer.parseInt(st.nextToken());
            value[i] = Integer.parseInt(st.nextToken());
        }

        /*
         * ===== DP 테이블 및 점화식 설계 =====
         *
         * 【DP 테이블 정의】
         * dp[i][w] = i번째 물품까지 고려했을 때, 무게 w 이하로 얻을 수 있는 최대 가치
         *
         * 【점화식 도출 상세 과정】
         * 현재 상태 dp[i][w]에서 고려해야 할 선택:
         *
         * 1) i번째 물품을 담지 않는 경우:
         *    - 무게 변화 없음: w 그대로
         *    - 가치: dp[i-1][w] (이전 최적해 그대로)
         *
         * 2) i번째 물품을 담는 경우 (단, w >= weight[i]일 때만):
         *    - 무게 사용: w에서 weight[i]만큼 차감
         *    - 가치: dp[i-1][w-weight[i]] + value[i]
         *    - 해석: "i번째 물품을 위한 공간을 확보한 후, 남은 공간에서 최적해 + 현재 물품 가치"
         *
         * 최종 점화식:
         * dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])
         *
         * 【왜 이 점화식이 맞는가?】
         * - 모든 가능한 선택을 고려함 (담기 vs 안담기)
         * - 각 선택의 결과를 이전의 최적해를 기반으로 계산
         * - 탐욕적 선택이 아닌 모든 조합을 고려한 최적해
         */
        int[][] dp = new int[N + 1][K + 1];

        // DP 테이블 채우기 - 물품을 하나씩 고려
        for (int i = 1; i <= N; i++) {
            // 각 무게에 대해 최적해 계산
            for (int w = 1; w <= K; w++) {
                /*
                 * ===== 핵심 DP 로직 상세 분석 =====
                 *
                 * 현재 물품(i번째)을 배낭에 담을지 말지 결정하는 과정
                 *
                 * 【선택 1: 물품을 담지 않는 경우】
                 * - 결과: dp[i-1][w] (이전 상태 그대로 유지)
                 * - 의미: "i번째 물품 없이도 이미 최적해를 달성한 상태"
                 * - 언제 유리한가: 현재 물품의 가성비가 나쁘거나, 담을 공간이 부족할 때
                 */

                // 현재 물품을 담지 않는 경우의 가치 (기본값 설정)
                // 이는 "안전한 선택"으로, 항상 유효한 값을 보장함
                dp[i][w] = dp[i-1][w];

                // 현재 물품을 담을 수 있는지 용량 검사
                if (w >= weight[i]) {
                    /*
                     * 【선택 2: 물품을 담는 경우 상세 분석】
                     *
                     * dp[i-1][w-weight[i]] + value[i]의 의미:
                     *
                     * 1) w-weight[i]: 현재 물품을 담기 위해 필요한 용량을 미리 확보
                     *    → "현재 물품을 담을 자리를 만들어 놓기"
                     *
                     * 2) dp[i-1][w-weight[i]]: 용량을 확보한 상태에서 이전 물품들만으로 얻을 수 있는 최대 가치
                     *    → "남은 공간을 최대한 효율적으로 활용한 결과"
                     *
                     * 3) + value[i]: 확보된 공간에 현재 물품을 담아서 얻는 가치
                     *    → "현재 선택의 직접적 이익"
                     *
                     * 【왜 이 방식이 최적인가?】
                     * - 현재 물품을 담기로 했다면, 남은 공간에서는 반드시 최적해를 선택해야 함
                     * - dp[i-1][w-weight[i]]는 이미 계산된 최적해이므로 신뢰할 수 있음
                     * - 부분 최적해들의 조합으로 전체 최적해를 구성 (최적 부분 구조 원리)
                     *
                     * 【흔한 실수와 주의점】
                     * - dp[i][w-weight[i]]를 쓰면 안 됨! → i번째 물품을 중복 사용하게 됨
                     * - 반드시 dp[i-1][w-weight[i]]를 써야 이전 상태의 최적해를 보장
                     */
                    dp[i][w] = Math.max(dp[i][w], dp[i-1][w-weight[i]] + value[i]);

                    /*
                     * Math.max를 사용하는 이유:
                     * - "담지 않기" vs "담기" 중 더 유리한 선택을 자동으로 선택
                     * - 이것이 바로 "최적 선택의 핵심"
                     * - 모든 가능성을 고려한 후 최선의 결과만 취함
                     */
                }
            }
        }

        /*
         * 결과 출력: dp[N][K]
         * = 모든 물품(N개)을 고려했을 때, 용량 K 이하에서 얻을 수 있는 최대 가치
         */
        System.out.println(dp[N][K]);
    }
}

/*
 * ===== 메모리 최적화 버전 (1차원 DP) =====
 *
 * 위 코드는 이해를 위한 2차원 버전이고, 실제로는 1차원으로 최적화 가능:
 *
 * int[] dp = new int[K + 1];
 *
 * for (int i = 1; i <= N; i++) {
 *     // 뒤에서부터 갱신 (중복 사용 방지)
 *     for (int w = K; w >= weight[i]; w--) {
 *         dp[w] = Math.max(dp[w], dp[w - weight[i]] + value[i]);
 *     }
 * }
 *
 * 【뒤에서부터 갱신하는 이유】
 * - 앞에서부터 하면 같은 물품을 여러 번 사용하게 됨 (무한배낭이 되어버림)
 * - 뒤에서부터 하면 이전 상태(i-1)의 값을 보장할 수 있음
 *
 * ===== 실전 팁 =====
 * 1. 물품 번호를 1부터 시작하면 DP 테이블 인덱싱이 자연스러움
 * 2. 무게가 0일 때는 항상 가치가 0 (초기화 불필요)
 * 3. 메모리 제한이 빡빡하면 1차원 최적화 버전 사용
 * 4. 실제 선택한 물품을 알아야 하면 역추적(backtracking) 필요
 */