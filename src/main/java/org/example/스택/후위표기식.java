package org.example.스택;

import java.util.*;

/*
 * 중위 표기식을 후위 표기식으로 변환하는 알고리즘 (Shunting Yard Algorithm)
 * 
 * === 알고리즘 기본 원리 ===
 * 1. 스택을 사용하여 연산자의 우선순위를 관리
 * 2. 피연산자는 바로 결과에 추가
 * 3. 연산자는 우선순위에 따라 스택에 저장하거나 결과에 추가
 * 4. 괄호는 특별한 규칙으로 처리 (여는괄호: 스택에 저장, 닫는괄호: 여는괄호까지 모든 연산자 pop)
 * 
 * === 시간복잡도 ===
 * - 시간복잡도: O(n) - 각 문자를 한 번씩만 처리
 * - 공간복잡도: O(n) - 스택과 결과 문자열 저장
 * 
 * === 사전 지식 ===
 * - 스택(Stack) 자료구조와 LIFO 원리
 * - 연산자 우선순위 (*, / > +, -)
 * - 문자열 처리 및 StringBuilder 사용법
 * 
 * === 코딩테스트 출제 유형 ===
 * 1. 수식 계산 문제의 전처리 단계
 * 2. 계산기 구현 문제
 * 3. 스택 응용 문제
 * 4. 문자열 파싱 문제
 * 5. 컴파일러/인터프리터 관련 문제
 * 
 * === 비슷한 알고리즘과 구별점 ===
 * 1. 후위표기식 계산: 이 알고리즘의 다음 단계, 혼동하지 말 것
 * 2. 괄호 짝 맞추기: 단순 괄호 검증은 다른 알고리즘
 * 3. 수식 파싱: 더 복잡한 토큰화가 필요한 경우와 구별
 * 4. 전위표기식 변환: 비슷하지만 다른 순서로 처리
 * 
 * === 주의사항 ===
 * - 연산자 우선순위를 정확히 구현해야 함
 * - 괄호 처리 로직이 핵심 (여는괄호는 절대 결과에 추가하지 않음)
 * - 마지막에 스택에 남은 연산자들을 모두 결과에 추가해야 함
 */
public class 후위표기식 {
    
    public static void main(String[] args) {
        // 테스트 케이스들 - 실제 코딩테스트에서는 이 부분만 수정하면 됨
        String infix1 = "A+B*C";           // 예상 결과: ABC*+
        String infix2 = "(A+B)*C";         // 예상 결과: AB+C*
        String infix3 = "A+B*C-D/E";       // 예상 결과: ABC*+DE/-
        String infix4 = "((A+B)*C-D)/E";   // 예상 결과: AB+C*D-E/
        
        System.out.println("입력: " + infix1 + " → 출력: " + infixToPostfix(infix1));
        System.out.println("입력: " + infix2 + " → 출력: " + infixToPostfix(infix2));
        System.out.println("입력: " + infix3 + " → 출력: " + infixToPostfix(infix3));
        System.out.println("입력: " + infix4 + " → 출력: " + infixToPostfix(infix4));
    }
    
    // 연산자 우선순위를 반환하는 메서드
    // 높은 숫자일수록 높은 우선순위 (*, /가 +, -보다 먼저 계산됨)
    private static int getPrecedence(char operator) {
        switch (operator) {
            case '+':
            case '-':
                return 1;  // 낮은 우선순위
            case '*':
            case '/':
                return 2;  // 높은 우선순위
            default:
                return 0;  // 연산자가 아닌 경우
        }
    }
    
    // 연산자인지 확인하는 메서드
    private static boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/';
    }
    
    // 중위표기식을 후위표기식으로 변환하는 핵심 메서드
    public static String infixToPostfix(String infix) {
        // 결과를 저장할 StringBuilder (문자열 연산 최적화)
        StringBuilder result = new StringBuilder();
        
        // 연산자를 임시 저장할 스택
        // ★ 핵심 원리: 스택은 "나중에 계산할 연산자"를 저장하는 대기실 역할
        // 후위표기식 = 피연산자들 + 연산자(계산 순서대로)
        Stack<Character> stack = new Stack<>();
        
        // 입력 문자열을 한 문자씩 처리
        for (int i = 0; i < infix.length(); i++) {
            char current = infix.charAt(i);
            
            // 1. 피연산자(A, B, C 등)인 경우
            if (Character.isLetterOrDigit(current)) {
                // ★ 왜 바로 결과에 추가하나?
                // 후위표기식에서는 피연산자가 연산자보다 항상 먼저 나와야 함
                // 예: A+B → AB+ (A와 B가 먼저, +가 나중)
                result.append(current);
            }
            
            // 2. 여는 괄호 '('인 경우
            else if (current == '(') {
                // ★ 여는 괄호를 스택에 넣는 이유?
                // 괄호는 "여기서부터 우선순위 계산을 새로 시작한다"는 경계선 역할
                // 닫는 괄호가 나올 때까지 다른 연산자들이 밖으로 나가지 못하게 막는 벽 역할
                stack.push(current);
            }
            
            // 3. 닫는 괄호 ')'인 경우
            else if (current == ')') {
                // ★ 핵심 직관: 괄호 안의 모든 계산을 지금 당장 처리해야 함!
                // 왜? 괄호는 최고 우선순위이므로 더 이상 미룰 수 없음
                // 예: (A+B)*C에서 )를 만나면 A+B를 먼저 계산해야 함
                while (!stack.isEmpty() && stack.peek() != '(') {
                    // 여는괄호까지의 모든 연산자를 "지금 계산하라"고 결과에 추가
                    result.append(stack.pop());
                }
                // 여는 괄호 '('를 제거 (괄호는 계산에 필요없으므로 버림)
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            }
            
            // 4. 연산자(+, -, *, /)인 경우 - 가장 복잡하고 직관적이지 않은 부분!
            else if (isOperator(current)) {
                // ★ 핵심 질문: 왜 기존 연산자들을 먼저 처리하는가?
                // 
                // 직관적 설명:
                // A + B * C에서 *를 만났을 때, +는 아직 스택에 대기 중
                // * 우선순위 > + 우선순위 이므로, *를 나중에 처리해야 함
                // 따라서 +는 그대로 두고 *만 스택에 추가
                //
                // A * B + C에서 +를 만났을 때, *는 스택에 대기 중  
                // + 우선순위 < * 우선순위 이므로, *를 먼저 처리해야 함
                // 따라서 *를 결과에 추가하고 +를 스택에 넣음
                //
                // A - B + C에서 +를 만났을 때, -는 스택에 대기 중
                // + 우선순위 = - 우선순위, 하지만 좌결합성에 의해 -를 먼저 계산
                // 따라서 -를 결과에 추가하고 +를 스택에 넣음
                
                while (!stack.isEmpty() && 
                       stack.peek() != '(' && 
                       getPrecedence(stack.peek()) >= getPrecedence(current)) {
                    // ★ 이 연산자는 "지금 계산할 때가 되었다"고 판단하여 결과에 추가
                    result.append(stack.pop());
                }
                
                // ★ 현재 연산자는 "아직 계산할 때가 아니다"고 판단하여 스택에서 대기
                // 나중에 더 낮은 우선순위 연산자가 오거나, 식이 끝나면 처리됨
                stack.push(current);
            }
        }
        
        // 5. 입력 처리 완료 후, 스택에 남은 모든 연산자를 결과에 추가
        // ★ 왜 이 단계가 필요한가?
        // 스택에 남은 연산자들 = "아직 계산 안된 연산자들"
        // 식이 끝났으므로 이제 모든 연산자를 계산해야 함
        // 스택에서 나오는 순서 = 계산해야 할 순서 (LIFO의 마법!)
        while (!stack.isEmpty()) {
            result.append(stack.pop());
        }
        
        return result.toString();
    }
}

/*
 * === 왜 이 방법으로 후위표기식이 만들어지는가? 핵심 원리 ===
 * 
 * ★ 기본 아이디어: "계산 순서를 뒤로 미루기"
 * 
 * 중위표기식: A + B * C (사람이 쓰는 방식)
 * 후위표기식: A B C * + (컴퓨터가 계산하기 쉬운 방식)
 * 
 * 1. 사람은 *를 나중에 보지만 먼저 계산해야 한다는 것을 안다
 * 2. 컴퓨터는 연산자를 보는 순간 바로 계산하고 싶어한다
 * 3. 따라서 "지금 계산하면 안 되는 연산자"를 스택에 보관한다
 * 4. "지금 계산해야 하는 연산자"를 결과에 바로 추가한다
 * 
 * === 직관적 예시로 이해하기 ===
 * 
 * 입력: A + B * C
 * 
 * 1. 'A': 피연산자 → "A는 언제나 필요하니까 바로 써둔다" → result = "A"
 * 2. '+': 연산자 → "아직 B를 모르니까 +는 나중에 계산해야지" → stack = ['+']
 * 3. 'B': 피연산자 → "B도 필요하니까 바로 써둔다" → result = "AB"
 * 4. '*': 연산자 → "+보다 *가 먼저 계산되어야 하니까 *도 잠깐 기다려" → stack = ['+', '*']
 * 5. 'C': 피연산자 → "C도 필요하니까 바로 써둔다" → result = "ABC"
 * 6. 종료: "이제 계산할 차례! 스택에서 하나씩 꺼내자"
 *    - 먼저 '*' 꺼냄 (B와 C를 곱해라) → result = "ABC*"
 *    - 다음 '+' 꺼냄 (A와 (B*C)를 더해라) → result = "ABC*+"
 * 
 * === 스택이 "시간여행" 장치인 이유 ===
 * 
 * 중위표기식에서는 연산자를 "나중에 쓸 걸 미리 보는" 상황이 발생
 * 예: A + B * C에서 +를 봤지만, *를 먼저 계산해야 함
 * 
 * 스택의 역할:
 * - "이 연산자는 아직 때가 아니야, 잠깐 보관해두자" (push)
 * - "이제 이 연산자를 쓸 때가 되었어!" (pop)
 * 
 * === 우선순위 비교의 직관적 의미 ===
 * 
 * while (스택의 연산자 우선순위 >= 현재 연산자 우선순위)
 * 
 * 이것의 의미: "스택에 있는 연산자가 현재 연산자보다 먼저 계산되어야 한다"
 * 
 * 예시:
 * - A * B + C에서 +를 만났을 때
 * - 스택에 있는 * (우선순위 2) >= 현재 + (우선순위 1)
 * - "곱셈을 먼저 해야 하니까 *를 지금 결과에 추가하자!"
 * 
 * === 괄호의 마법 ===
 * 
 * (A + B) * C에서:
 * 1. '(' → 스택에 넣기 (경계선 역할)
 * 2. A → 결과에 추가
 * 3. '+' → 스택에 넣기 [stack: '(', '+']
 * 4. B → 결과에 추가  
 * 5. ')' → "괄호 안을 지금 당장 계산해!" 
 *          '('까지 모든 연산자 pop → '+'를 결과에 추가
 * 6. '*' → 이제 괄호 계산이 끝났으니 *를 스택에 넣기
 * 
 * 결과: AB+C* (괄호가 우선순위를 강제로 바꿨다!)
 * 
 * === 핵심 깨달음 ===
 * 이 알고리즘은 "연산자들의 대기 줄"을 관리하는 것!
 * - 피연산자: 바로 처리 (대기할 필요 없음)
 * - 연산자: 우선순위에 따라 대기하거나 바로 처리
 * - 스택 = 대기실, 결과 = 실제 계산 순서
 */