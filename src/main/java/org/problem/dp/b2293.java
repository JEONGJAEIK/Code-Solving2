package org.problem.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

// 골드 4 동전 1
public class b2293 {
    static int[] arr;
    static long result;
    static int[] dp;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken()); // 동전 종류 100
        int k = Integer.parseInt(st.nextToken()); // 목표 가치 1만

        arr = new int[n];
        dp = new int[k + 1];

        for (int i = 0; i < n; i++) {
            st = new StringTokenizer(br.readLine());
            arr[i] = Integer.parseInt(st.nextToken()); // 각 동전 가치는 최대 10만
        }

        // 중복조합 or dp?
        // 백트래킹을 한다고해도.. 중복조합이면 2의 1만제곱까지 가능함 이건 종류나열이 아닌 경우의 수만 필요함.
        // dp 해야할듯 dp[10] = dp[9] + 1 만약 1인동전이있다면
        // dp[k]를 구해야 함 어느 가치의 동전이 들어올지 모름
        // 근데 사용한 동전의 구성이 같을때 순서만 다른건 같은 경우 즉 123 321은 같다 동전의 구성을 구해야함
        // 즉 구해야하는건 경우의 수가 아닌 가능한 동전의 구성 종류임
        // 1 2 5,  10
        // 1111111111
        // 211111111
        // 22111111
        // 2221111
        // 222211
        // 22222
        // 511111
        // 52111
        // 5221
        // 55
        // dp[1] = 1 자기자신
        // dp[2] = 11, 2 합이 2가 되려면 dp[1]의 기존값을 더하고 새로운 자기자신을 추가
        // dp[3] = 111, 21 dp[2]뒤에 dp[1]을 더하는데 중복값 없음
        // dp[4] = 1111, 211, 22 dp[2]뒤에 dp[2]를 더하는데 중복값 -1를 뺌 dp[2] + dp[2] - 1
        // dp[5] = 11111, 2111, 221, 5 dp[4] + 자기자신
        // dp[6] = 111111, 21111, 2211, 222, 51 dp[4] + dp[2]
        // dp[7] = 1111111, 211111, 22111, 2221, 511, 52 기존 dp[6]에 dp[1]의 값을더하고 11을 2로 변환
        // 새로운 동전이 등장했을 때 동전을 최소 한번 사용해서 i라는 가치를 만들 수 있는 방법이 이전 가치들의 방법과 어떤 규칙적인 관계를 맺는가
        // 새로운 동전 i 가 등장하면 dp[i]가 + 1 된다. dp[i - 1] + 1이다.
        // 2차원 dp?

        // dp[가치][동전 종류] dp[1][1] = 1
        // dp[2][1] = 1 dp[2][2] = 1
        // dp[3][1] = 1 dp[3][2] = 0 ,21 2과 1가 섞인건?
        // dp[4][1] = 1 dp[4][2] = 1 ,211
        // dp[5][1] = 1 dp[5][2] = 0, dp[5][5] = 1, 2111 221은?

        // 아니 dp[가치][동전 개수]?
        // dp[1][1] = 1 합 1
        // dp[2][1] = 1 dp[2][2] = 1 합 2
        // dp[3][1] = 0 dp[3][2] = 1 dp[3][3] = 1 합 2
        // dp[4][1] = 0 dp[4][2] = 1 dp[4][3] = 1 dp[4][4] = 1 합 3
        // dp[5][1] = 1 dp[5][2] = 0 dp[5][3] = 1 dp[5][4] = 1 dp[5][5] = 1 합 4
        // dp[6][1] = 0 dp[6][2] = 0 dp[6][3] = 1 dp[6][4] = 1 dp[6][5] = 1 dp[6][6] = 1 합 5
        // dp[7][1] = 0 dp[7][2] = 2 dp[7][3] = 1 dp[7][4] = 1 dp[7][5] = 1 dp[7][6] = 1 dp[7][7] = 1 합 6

        // dp[n][n]은 항상 1이다 1로만 구성됨
        // dp[n][1]은 새로운 동전이 들어올때만 1이다 n이 5일때 5로 완성된다.
        // 그런데 동전 개수로하면 dp[n][1만]까지 가능하지않나 괜찮을까?
        // 기본적으로 dp[a][b] + dp[a + 1][b + 1] 같다 1이 추가되니까 그런데 새로운 패턴이 추가되면 보장되지않음

        // dp[가치][동전종류][동전개수]?
        // 3차원까진 아닌거같은데..
        // dp[1][1][1] = 1
        // dp[2][1][2] = 1 dp[2][2][1] = 1
        // dp[3][1][3] = 1 dp[3][2][1] = 1 dp[3][1][1] = 1

        // dp[동전종류][동전개수]
        // dp[1][1] = 1
        // dp[1][2] = 2 dp[2][1] = 2 값은 목표수 가짓수는 곧 경우의수 2 값을 더해서 총합이 되는 경우의수?
        // dp[1][3] = 3
        // dp[1][4] = 4 dp[2][2] = 4 // dp4는 1 4개와 2 2개가 dp[1][2] dp[2][1]을 더한 하나의 경우
        // dp[1][5] = 5 dp[5][1] = 5 // 5가 되는 경우의 수는 5자리 2개와

        // 최소가치동전 부터 만들어보자
        // dp[가치]
        // dp[1] = 1  1
        // dp[2] = 1  11
        // dp[3] = 1  111
        // ...
        // 중간가치 동전
        // dp[1] = dp[1] // 2는 불가
        // dp[2] = dp[1] + 1 // 2 본인 삽입 11 2
        // dp[3] = dp[2] // 111 21
        // dp[4] = dp[3] + 1 // 2 본인 삽입 1111 211 22
        // dp[5] = dp[4] // 11111 2111 221
        // dp[6] = dp[5] + 1 // 2 본인 삽입 111111 21111 2211 222
        // dp[7] = dp[6] // 4개

        // 마지막 동전
        // dp[1] = dp[1]
        // ....
        // dp[5] = dp[4] + 1 // 본인삽입 // 11111 2111 221 5
        // dp[6] = dp[5] // 111111 21111 2211 222 51 5개
        // dp[7] = dp[7] + dp[7 - 2] // 5가 아니기 때문에 본인삽입 없음 1111111 211111 22111 2221 511 52 실제로는 6개인데 답은 5개 52 <- 이부분을 어떻게 처리?
        Arrays.sort(arr);
        dp[0] = 1;

        for (int coin : arr) {
            for (int i = coin; i <= k; i++) {
                dp[i] = dp[i] + dp[i - coin];
            }
        }

        result = dp[k];
        System.out.println(result);
    }
}
